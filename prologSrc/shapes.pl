:-module(shapes,[find_polygons/2,find_polygons/3,find_all_polygons/2,polygons_to_segments/2,front_face/2]).
:-reexport('primitives.pl',[area/2]).
:-use_module('debug.pl').
:-use_module('geometry.pl').
:-use_module('primitives.pl').
:-use_module(library(apply)).
:-use_module(library(lists)).

threshold(N,N):-
	integer(N),
	N>0,
	N<255.
threshold(light,255).
threshold(dark,0).
threshold(medium,-1).

find_all_polygons(I,LP):-
	find_polygons(I,[all],LP).

find_polygons(I,LP):-
	find_polygons(I,[],LP).
find_polygons(I,Opt,LP):-
	(	member(threshold(T),Opt),!
	;	T=medium
	),
	threshold(T,Th),
	(	member(border(B),Opt)
	->	find_polygons(I,B,Th,Opt,LP)
	;	find_polygons(I,1,Th,Opt,LP1),
		find_polygons(I,2,Th,Opt,LP2),
		length(LP1,L1),
		length(LP2,L2),
		(	L2>L1
		->	LP=LP2
		;	LP=LP1,
			find_all_polygons(I,1,Th,_)	%%%only for debug
		)
	).
find_polygons(I,B,Th,Opt,LP):-
	find_all_polygons(I,B,Th,LPA),
	(	member(all,Opt)
	->	LP=LPA
	;	include(front_face_,LPA,LP)
	).

polygons_to_segments(LP,LSeg):-
	maplist(edges,LP,LLSeg),
	append(LLSeg,LSegDup),
	clean_seg(LSegDup,LSegDupCleaned),
	tolerance(T),
	set_tolerance(0),
	list_to_set_equals(LSegDupCleaned,LSeg),
	set_tolerance(T),
	%show(LSeg),							%%%only for debug
	!.

clean_seg(LSeg,LSegCl):-
	clean_seg_iter(LSeg,[],LSeg,[],LSegCl,[],[],_).
clean_seg_iter(LSeg,LSegDone,[seg(P1,P2)|LSegToDo],LSegClDone,LSegCl,LPClDone,LEqDone,LEq):-
	!,
	clean_point(P1,LPClDone,LEqDone,LSeg,P1Cl,LPCl1,LEq1),
	clean_point(P2,LPCl1,LEq1,LSeg,P2Cl,LPCl2,LEq2),
	clean_seg_iter(LSeg,[seg(P1,P2)|LSegDone],LSegToDo,[seg(P1Cl,P2Cl)|LSegClDone],LSegCl,LPCl2,LEq2,LEq).
clean_seg_iter(_,_,[],LSegClDone,LSegCl,_,LEq,LEq):-
	reverse(LSegClDone,LSegCl).
	
clean_point(P,LPCl,LEq,_,P,LPCl,LEq):-
	member(P,LPCl),
	!.
clean_point(P,LPCl,LEq,_,PCl,LPCl,LEq):-
	member([PCl|Eq],LEq),
	member(P,Eq),
	!.
clean_point(P,LPCl,LEq,LSeg,PCl,LPCl,LEqNew):-
	member([PCl|Eq],LEq),
	member_equals(P,[PCl|Eq],_),
	no_segment_to_eq_class_member(P,[PCl|Eq],LSeg),
	!,
	append(LEqH,[[PCl|Eq]|LEqT],LEq),
	append(LEqH,[[PCl,P|Eq]|LEqT],LEqNew).
clean_point(P,LPCl,LEq,_,P,[P|LPCl],[[P]|LEq]).

no_segment_to_eq_class_member(P,Eq,LSeg):-
	member(PCl,Eq),
	\+member(seg(P,PCl),LSeg),
	\+member(seg(PCl,P),LSeg).

front_face_(poly(_,[p(X1,Y1),p(X2,Y2)|_])):-	%use only on polygons generated by find_polygons!
	X1*Y2-X2*Y1>0.
/*front_face_(P):-
	front_face(P).*/
front_face(poly(N,[p(X1,Y1),p(X2,Y2),p(X3,Y3)|TV])):-
	midpoint(seg(p(X1,Y1),p(X3,Y3)),PM),
	(	contains(poly(N,[p(X1,Y1),p(X2,Y2),p(X3,Y3)|TV]),PM)
	->	(X2-X1)*(Y3-Y2)-(X3-X2)*(Y2-Y1)<0
	;	(X2-X1)*(Y3-Y2)-(X3-X2)*(Y2-Y1)>0
	).

front_face(poly(N,LV),poly(N,LVRev)):-
	\+front_face(poly(N,LV)),
	!,
	reverse(LV,LVRev).
front_face(P,P).
